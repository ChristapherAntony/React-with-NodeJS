const colors = require('colors')
const fs = require('fs')
const term = require( 'terminal-kit' ).terminal 
const TextBuffer = require( 'terminal-kit' ).TextBuffer
const escapeStringRegexp = require('escape-string-regexp');

const mongoosen = (function(){

    var setting = {}

    const types = ['String', 'Number', 'Date', 'Buffer', 'Boolean', 'Mixed', '[]']
    
    var globalSteps = []

    var globalStepsValues = { length: 0 }

    var steps = [
        { text: 'New field name (press <enter> to stop adding fields)', preText: 'Available types::_green ' + types.join(', ') + ':_yellow' },
        { text: 'Field type', key: 'type', values: [...types,  ...types.map((item) => { return `[${item}]`;  })], default: types[0] },
        { text: 'Field default value (press <enter> to skip)', key: 'default',  type: () => { return { schematype: schemaType }  }, skipEmpty: true },
        { text: 'Required', key: 'required', values: [false, true], type: 'Boolean', default: 'false' },
        { text: 'Unique', key: 'unique', values: [false, true], type: 'Boolean', default: 'false'  },
        { text: 'Index (press <enter> to skip)', key: 'index', skipEmpty: true },
    ]

    // console.log(steps[1].values)

    var idx = 0

    var currentStep = null

    var textBuffer = TextBuffer.create()
    var hintBuffer = TextBuffer.create()
    var schemaBuffer = TextBuffer.create()
    var schemaKey = null
    var schemaType = null
    var schemaItem = {}


    var nextStep = () =>
    {

        textBuffer.setText('')

        if(globalStepsValues.length < globalSteps.length)
        {
            currentStep = globalSteps[globalStepsValues.length]
            globalStepsValues.length++

            if(typeof currentStep.plugin === 'string')
            {
                try
                {
                    require.resolve(currentStep.plugin)
                }
                catch(e)
                {
                    globalStepsValues[currentStep.key] = currentStep.values[0]
                    nextStep()
                    return;
                }
            }

        }
        else
        {
            if(typeof steps[idx] === 'undefined')
            {
                if(idx) idx = 0
                else exit()
            }

            currentStep = steps[idx]
            idx++

            if(typeof globalStepsValues[currentStep.key] != 'undefined' && globalStepsValues[currentStep.key] === false)
            {
                nextStep()
                return;
            }

            if(idx === 1) term("\n")

            if(typeof currentStep.preText == 'string') showQuestion(currentStep.preText + "\n\n")

        }
        
        showQuestion(currentStep.text, typeof currentStep.default != 'undefined' ? currentStep.default : null, ': ')
        
    }

    var colorize = (text) => {
        let result = ''
        let colors = text.match(/:_[a-z]+/g)
        let texts = text.split(/:_[a-z]+/g)
        for(let i in texts)
        {
            result += texts[i][colors && typeof colors[i] === 'string' ? colors[i].substr(':_'.length) : 'green']
        }

        return result
    }

    var showQuestion = (text, hint, suffix) => {

        term(colorize(text))
        if(hint) term(` [${hint.cyan}]`)
        if(suffix) term(suffix)
    }

    var convert = (type, value) => {

        if(typeof type == 'function')
        {
            let result = type.apply(this)
            if(result.schematype === undefined ) return result
            else {
                return convert(result.schematype, value)
            }
        }
        else
        {
            switch(type)
            {
                case 'Number': return new Number(value)
                case 'Boolean': return value.toLowerCase() !== 'false'
                case 'String': return `'${value}'`
                default: return value
            }
        }
    }

    var setSchema = () => {

        let value = (textBuffer.getText() + hintBuffer.getText()).trim()

        if(value || typeof currentStep.key === 'string')
        {
            if(typeof currentStep.key === 'undefined')
            {
                 if(schemaBuffer.getText()) schemaBuffer.insert("},\n")
                 schemaBuffer.insert("\t" + value + ": {")
                 schemaKey = value
            } 
            else
            {
                if(schemaKey)
                {
                    if(typeof currentStep.skipEmpty == 'undefined' || !currentStep.skipEmpty || value !== '' )
                    {
                        if(value === '') value = currentStep.default
                        if(currentStep.key === 'type') schemaType = value
                        // if(typeof currentStep.helper == 'function') schema[schemaKey][currentStep.key] = currentStep.helper(schema[schemaKey].type, value)
                        // else 
                        // schema[schemaKey][currentStep.key] = value
                        schemaBuffer.insert((idx > 2 ? ', ' : '' ) + currentStep.key + ": " + convert(currentStep.type, value))
                    }
                }
                else
                {
                    globalStepsValues[currentStep.key] = convert(currentStep.type, value)
                }
                
            }
        }
        else 
        {
             if(schemaBuffer.getText()) schemaBuffer.insert("}")
             buildSchemaFile()
             exit()
        }

        textBuffer.setText('')

    }

    var currentStepIsRequired = () => {
        return typeof currentStep.required !== 'undefined' && currentStep.required
    }

    var buildSchemaFile = () => {
        let schemaTopBuffer = TextBuffer.create()
        let schemaBottomBuffer = TextBuffer.create()


        if(!setting.jsonOnly)
        {

            schemaBottomBuffer.newLine()
            schemaBottomBuffer.newLine()

            schemaTopBuffer.insert("'use strict'\n\n")
            schemaTopBuffer.insert("const mongoose = require('mongoose');\n")
            

            for( let gs of globalSteps )
            {
                if(typeof gs.plugin == 'string' && globalStepsValues[gs.key])
                {
                    schemaTopBuffer.insert(`const ${gs.key} = require('${gs.plugin}');\n`)

                    schemaBottomBuffer.insert(`${setting.name}Schema.plugin(${gs.key}${typeof gs.pluginOptions == 'object' ? ', ' + JSON.stringify(gs.pluginOptions).replace(/(:|\,)/g, '$1 ') : ''})\n`)
                }
            }

            schemaTopBuffer.newLine()
            schemaTopBuffer.insert(`const ${setting.name}Schema = new mongoose.Schema({\n`)
            schemaTopBuffer.insert(schemaBuffer.getText())
            schemaTopBuffer.insert("\n})")

            if(setting.withModel)
            {
                schemaBottomBuffer.insert(`\n\nconst ${setting.name} = mongoose.model('${setting.name}', ${setting.name}Schema)`)
                schemaBottomBuffer.insert(`\nmodule.exports = ${setting.name}`) 
            }
            else {
                schemaBottomBuffer.insert(`\nmodule.exports = ${setting.name}Schema`) 
            }

            
        }
        else
        {
            schemaTopBuffer.insert("\n{\n" + schemaBuffer.getText() + "\n}")
        }  

        if(typeof setting.output === 'string') fs.writeFileSync(setting.output, schemaTopBuffer.getText() + schemaBottomBuffer.getText());
        else term("\n" + schemaTopBuffer.getText() + schemaBottomBuffer.getText() + "\n")
    }

    var validate = () => {

    }

    var exit = () => {
        term("\n")
        process.exit()
    }

    this.start = (params) => {

        setting = params

        term.grabInput();

        term.on( 'key' , function( name , matches , data ) {  
            
            // console.log( "'key' event:" , name ) ;
            
            switch ( name ) { 
                case 'CTRL_C': exit() ; break;
                case 'LEFT' : /*term.left( 1 ) ;*/ break ;
                case 'RIGHT' : /*term.right( 1 ) ;*/ break ;
                case 'BACKSPACE': 
                    term.eraseLineAfter()
                    if(textBuffer.getText())
                    {
                        textBuffer.backDelete(); 
                        term.backDelete() ; 
                    }
                break;
                case 'TAB': 
                    let text = hintBuffer.getText()
                    term.eraseLineAfter()
                    term(text)
                    textBuffer.insert(text); 
                    hintBuffer.setText(''); 
                break;
                case 'ENTER':
                    if( !currentStepIsRequired() || textBuffer.getText() )
                    {
                        setSchema()
                        term("\n")  
                        nextStep()
                    }
                break;

                default: 

                 hintBuffer.setText('')
                 term.eraseLineAfter()


                 if(typeof currentStep.values == 'object')
                 {
                     // console.log(`|${textBuffer.getText()}|${name}|`)
                     let text = textBuffer.getText().trim() + name
                     let re = new RegExp(`\\|${escapeStringRegexp(text)}[^\\|]*`)
                     // console.log(re, `|${currentStep.values.join('|')}|`)
                     let match = `|${currentStep.values.join('|')}|`.match(re)
                     if(match)
                     {
                         term.saveCursor()
                         let hint = match[0].substr(text.length)
                         term.bgGray(hint.trim())
                         hintBuffer.setText(hint.substr(1))
                         term.restoreCursor()
                     } 
                 }

                if(currentStep.values === undefined || hintBuffer.getText())
                {
                    textBuffer.insert(name)
                    term(name)
                }
                    

                    
            }   
        } ) ;

        nextStep()
    }

    this.addGlobalStep = (step) => {
        globalSteps.push(step)
    }

    this.addStep = (step) => {
        steps.push(step)
    }

    return this

})()

module.exports = mongoosen;
